%% Batch save ROI velocities for all subjects
clc; clear; close all;

parentFolder = '/Users/TXV016/Desktop/WRAP2/SUBJ/PDT';

% Get subject folders
subjectDirs = dir(parentFolder);
subjectDirs = subjectDirs([subjectDirs.isdir]); % only folders
subjectDirs = subjectDirs(~ismember({subjectDirs.name}, {'.','..'})); % remove . and ..

ilist = 1:length(subjectDirs);
ilist = 1;

% Loop over subjects
for s = ilist
    subjFolder = fullfile(parentFolder, subjectDirs(s).name);
    fprintf('\nProcessing subject: %s\n', subjectDirs(s).name);

    [foldername, subjname] = fileparts(subjFolder);
    baseparent = fileparts(foldername);

    % Locate dist and velocity data
    dmatfile = fullfile(baseparent, 'CSFmasks', subjname, 'D.mat');
    load(dmatfile, 'D');
    dist = flip(D, 2);

    skel = bwskel(dist>0); 
    dskel = skel.*dist;

    % reduce skel to reflect shortest distance SC to LVs
    % constraint to follow pathway: SC - V4 - CA - V3 - L/R FMo - L/R LV

    WFs = [];
    ROIs = {'SC', 'V4', 'CA', 'V3'};
    wfdir = fullfile(subjFolder, 'Waveforms');
    for i = 1:numel(ROIs)
        ROI = ROIs{i};
        load(fullfile(wfdir, [ROI '.mat']));
        WFs.(ROI) = WF;
    end

    seedmap = zeros(size(dskel));
    for i = 1:4
        c = WFs.(ROIs{i}).coords;
        seedmap(c.x, c.y, c.z) = 1;
    end

    % Initialize output map
    seedskel = false(size(skel));

    % Get skeleton voxel coordinates
    [skelX, skelY, skelZ] = ind2sub(size(skel), find(skel));

    % For each seed, find the closest skeleton voxel
    for i = 1:4
        c = WFs.(ROIs{i}).coords; % seed coordinates
        seed = [c.x, c.y, c.z];

        % Compute squared distances to all skeleton voxels
        d2 = (skelX - seed(1)).^2 + (skelY - seed(2)).^2 + (skelZ - seed(3)).^2;

        % Find closest skeleton voxel
        [~, minIdx] = min(d2);
        snapped = [skelX(minIdx), skelY(minIdx), skelZ(minIdx)];

        % Mark in seedskel
        seedskel(snapped(1), snapped(2), snapped(3)) = true;
    end

end





